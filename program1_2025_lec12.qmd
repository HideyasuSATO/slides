---
title: "第12回 パイプライン化と実践的データ加工"
subtitle: "プログラミング演習Ⅰ"
author: 
  name: "佐藤 秀保"
  email: "sato0035@toyo.jp"
format:
  revealjs:
    self-contained: true
    theme: simple
    slide-number: true
    css: styles.css
    transition: slide
editor: visual
---

------------------------------------------------------------------------

## 準備

1.  [Posit Cloud](https://posit.cloud/)へ（日本語訳しないことを推奨）

2.  作成済みのプロジェクトをクリック

3.  先週使用のスクリプトをすべて閉じる

4.  新しくスクリプトを作成

5.  作成したスクリプトを保存：名前は「lecture11」

6.  ほうきボタンでオブジェクトを削除

7.  **library(tidyverse)を実行**

8.  **syokudo_data3をアップロード・読込**

授業中のコードはすべてスクリプトに書き実行すること

------------------------------------------------------------------------

## 先週までの内容

-   dplyrでデータ加工

```{r}
#| echo: true
#| eval: false
df1 <- filter(syokudo_data2, 客数 > 0)
df2 <- mutate(df1, 曜日 = weekdays(日付))
df3 <- filter(df2, 曜日 == "Monday")
df4 <- summarise(df3, 客数平均 = mean(客数))
```

１つの加工をするたびにデータフレームに保存するのはダルいのでは...？

------------------------------------------------------------------------

## [パイプライン化]{style="color: orange;"}

-   [パイプ演算子 %\>%]{style="color: orange;"} を用いて，

    [**左のもの（データフレーム）を右の関数の第１引数に渡す書き方**]{.underline}

-   例：

```{r}
#| echo: true
#| eval: false
#普通の書き方
df_normal <- filter(syokudo_data3, 客数 > 0)
#パイプライン化
df_pipe <- syokudo_data3 %>% filter(客数 > 0)
```

-   df_normalとdf_pipeの中身は全く同じ

------------------------------------------------------------------------

### 演習の解答をパイプライン化して書く

```{r}
#| echo: true
#| eval: false
#普通の書き方
df1 <- filter(syokudo_data3, 客数 > 0)
df2 <- mutate(df1, 曜日 = weekdays(日付))
df3 <- filter(df2, 曜日 == "Monday")
df4 <- summarise(df3, 客数平均 = mean(客数))

#パイプライン化
df <- syokudo_data3 %>% 
  filter(客数 > 0) %>% 
  mutate(曜日 = weekdays(日付)) %>% 
  filter(df2, 曜日 == "Monday") %>% 
  summarise(客数平均 = mean(客数))
```

-   おわかりいただけただろうか（df4とdfの中身は全く同じ）

------------------------------------------------------------------------

### **パイプ演算子** %\>% **の注意点**

-   %\>% は[Ctrl + Shift + m]{style="color: orange;"} で挿入可
-   %\>% の直後に改行すると見やすい
-   %\>% は tidyverseパッケージに含まれるので，tidyverseを読み込んでいないと使えない（エラー）
-   %\>% はデータフレーム以外のものも右の関数の第一引数に引き渡す．例えば-2の絶対値は；

```{r}
#| echo: true
#| eval: false
#普通の書き方
abs(-2)
#パイプライン化
-2 %>% abs()
```

------------------------------------------------------------------------

## 実践的なデータ加工例

### 欠損値NAの直接的扱い

-   「総売上」がNAの行のみを抽出

```{r}
#| echo: true
#| eval: false
df5 <- syokudo_data3 %>%
  filter(is.na(総売上))
```

-   is.na関数は，欠損値であるか否かをT/Fで判定

-   filter関数は，条件式の結果T/Fを受けてTに該当する行のみを抽出

------------------------------------------------------------------------

-   「総売上」がNA[**でない**]{.underline}行のみを抽出

```{r}
#| echo: true
#| eval: false
df6 <- syokudo_data3 %>%
  filter(!is.na(総売上))
```

-   [! は否定を表し]{style="color: orange;"}T/Fが逆転

------------------------------------------------------------------------

### グループ別の処理

-   曜日[**別**]{.underline}の「総売上」の平均値

```{r}
#| echo: true
#| eval: false
df7 <- syokudo_data3 %>%
  mutate(曜日 = weekdays(日付)) %>% 
  filter(!is.na(総売上)) %>% 
  summarise(総売上の平均 = mean(総売上), .by = 曜日)
```

-   [.by =]{style="color: orange;"}というキーワード引数で指定したグループ別に計算が可

（余談：昔は「group_by」という関数を使用しなければグループ別の処理ができなかったが，2023年1月以降，様々な関数内で「.by=」により可能に）

------------------------------------------------------------------------

### 値の変換と列の追加

-   [case_when関数]{style="color: orange;"}で条件を満たす値を別の値に変換可

-   文法：

    **case_when(条件式１ \~ 条件式1がTRUEの場合に返す値, 条件式２ \~条件式1が FALSEでかつ条件式２がTRUEの場合に返す値, 条件式３ \~ 条件式１と２がFALSEでかつ条件式３がTRUEの場合に返す値, ...., TRUE \~ すべての条件式がFALSEの場合に返す値）**

    -   見づらいので実際は適当なところで改行を入れることが多い

-   列追加のmutate関数内での使用が多い

---

-   例１：「総売上」がその平均値の1.2倍以上なら2，その平均値以上1.2倍未満なら1，それ以外なら0をとる「総売上階級」変数を追加

```{r}
#| echo: true
#| eval: false
df8 <- syokudo_data3 %>%
  filter(!is.na(総売上)) %>% 
  mutate(総売上階級 = case_when(
    総売上 >= 1.2*mean(総売上) ~ 2,
    総売上 >= mean(総売上) ~ 1,
    TRUE ~ 0)
    )
```

------------------------------------------------------------------------

-   例２：月曜日なら1，それ以外の曜日なら0をとる「月曜日ダミー」変数を作成
    -   特定の条件に該当する場合に1，それ以外は0をとる0/1の２値変数は[ダミー変数]{style="color: orange;"}とよばれ，データ分析で頻出

```{r}
#| echo: true
#| eval: false
df9 <- syokudo_data3 %>%
  mutate(曜日 = weekdays(日付),
         月曜日ダミー = case_when(
           曜日 == "Monday" ~ 1,
           TRUE ~ 0)
         )
```

------------------------------------------------------------------------

## 演習

　食堂では，客ごとに使用する金額にはそこまで差がないと考えられるため，「総売上が高い日であっても客単価には大差なく，単に客数が多いことが総売上を押し上げる要因だ」と考えているとしよう．

　このことを調べるために，まず「客単価」変数（=「総売上」÷「客数」）を作成し，次に，ざっくりと総売上のレベルをわけるために，「総売上」がその平均値の1.2倍以上なら3，平均値の1.2倍未満かつ平均値以上なら2，平均値未満かつ平均値の0.8倍以上なら1，それ以外なら0の「総売上階級」変数を作成，その後「総売上階級」別に「客単価」と「客数」の平均を計算し，「総売上階級」の値の昇順に並び替えよ．

---

　ただし，平均の計算にあたっては欠損値の除外を認め，また，コードを書く際にはパイプ演算子を有効に活用すること．

**完成データフレーム**：

![](images/lec12.png)

------------------------------------------------------------------------

## 課題

-   ACEの小テスト：「第12回」

-   ACEのレポート：「第12回」

    -   ローカルに保存したlecture12.Rを提出
